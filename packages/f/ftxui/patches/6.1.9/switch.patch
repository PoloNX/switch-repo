diff --git a/src/ftxui/component/loop.cpp b/src/ftxui/component/loop.cpp
index d16c67b4..6aac6317 100644
--- a/src/ftxui/component/loop.cpp
+++ b/src/ftxui/component/loop.cpp
@@ -20,7 +20,7 @@ namespace ftxui {
 // NOLINTNEXTLINE
 Loop::Loop(ScreenInteractive* screen, Component component)
     : screen_(screen), component_(std::move(component)) {
-  screen_->PreMain();
+  //screen_->PreMain();
 }
 
 Loop::~Loop() {
diff --git a/src/ftxui/component/screen_interactive.cpp b/src/ftxui/component/screen_interactive.cpp
index 77d164ac..1341d3a8 100644
--- a/src/ftxui/component/screen_interactive.cpp
+++ b/src/ftxui/component/screen_interactive.cpp
@@ -48,7 +48,12 @@
 #endif
 #else
 #include <sys/select.h>  // for select, FD_ISSET, FD_SET, FD_ZERO, fd_set, timeval
+#ifndef __SWITCH__
 #include <termios.h>  // for tcsetattr, termios, tcgetattr, TCSANOW, cc_t, ECHO, ICANON, VMIN, VTIME
+#else
+#include <switch.h>
+#include <fcntl.h>
+#endif
 #include <unistd.h>  // for STDIN_FILENO, read
 #endif
 
@@ -657,6 +662,82 @@ void ScreenInteractive::Install() {
 
   SetConsoleMode(stdin_handle, in_mode);
   SetConsoleMode(stdout_handle, out_mode);
+#elif defined(__SWITCH__)
+  // --- Initialisation des services Switch ---
+  consoleInit(NULL); // initialise la console texte ; utile pour debug/text output
+
+  // Configure l'entrée pour un joueur, styles standards de manettes
+  padConfigureInput(1, HidNpadStyleSet_NpadStandard);
+
+  // create a pipe: we will write translated pad bytes to pipe_write;
+  // the read end will be dup'd on STDIN so the rest of the code reads them.
+  int pad_pipe_fds[2] = {-1, -1};
+  if (pipe(pad_pipe_fds) == -1) {
+    // Si pipe échoue, continuez sans redirection : l'app va quand même fonctionner
+  } else {
+    // Make write end non-blocking (optional)
+    int flags = fcntl(pad_pipe_fds[1], F_GETFL, 0);
+    fcntl(pad_pipe_fds[1], F_SETFL, flags | O_NONBLOCK);
+
+    // Replace STDIN with the read end of our pipe so existing read() usage receives pad input.
+    // Note: sur Switch il n'y a pas forcément d'entrée standard utile, donc écraser STDIN est acceptable.
+    dup2(pad_pipe_fds[0], STDIN_FILENO);
+    // We can close the original read fd if dup2 succeeded (STDIN now points to same fd)
+    close(pad_pipe_fds[0]);
+  }
+
+  // Ensure we will cleanup libnx and the pipe on exit
+  std::atomic<bool> pad_thread_stop{false};
+  std::thread pad_thread;
+  if (pad_pipe_fds[1] != -1) {
+    // start pad thread that polls inputs and writes translated bytes to the pipe
+    pad_thread = std::thread([write_fd = pad_pipe_fds[1], &pad_thread_stop]() {
+      PadState pad;
+      padInitializeDefault(&pad);
+
+      // loop until requested to stop
+      while (!pad_thread_stop.load()) {
+        padUpdate(&pad);
+
+        u64 kDown = padGetButtonsDown(&pad);      // newly pressed buttons this frame
+        u64 kHeld = padGetButtons(&pad);          // currently held buttons
+
+        // build a small buffer of bytes to inject into stdin
+        std::string out;
+
+        // example mappings (à personnaliser)
+        if (kDown & HidNpadButton_Up)    out += "\x1b[A";  // arrow up
+        if (kDown & HidNpadButton_Down)  out += "\x1b[B";  // arrow down
+        if (kDown & HidNpadButton_Left)  out += "\x1b[D";  // arrow left
+        if (kDown & HidNpadButton_Right) out += "\x1b[C";  // arrow right
+        if (kDown & HidNpadButton_A)     out += '\n';      // Enter
+        if (kDown & HidNpadButton_B)     out += '\x1b';    // Escape
+        // Example: start/plus to request quit (application can map this)
+        if (kDown & HidNpadButton_Plus)  out += '\x18';    // Ctrl-X as "quit" signal (custom)
+
+        // write to the pipe (ignore short writes or EAGAIN)
+        if (!out.empty()) {
+          ssize_t w = write(write_fd, out.data(), (size_t)out.size());
+          (void)w;
+        }
+
+        // Sleep a short while to avoid busy loop. 16ms ~ 60Hz.
+        // Use svcSleepThread on Switch for high precision or usleep.
+        // svcSleepThread(16000000); // 16 ms (16,000,000 ns) if you want to use svc
+        usleep(16000);
+      }
+      // close write fd
+      close(write_fd);
+    });
+  }
+
+  // On exit, stop the thread and cleanup
+  on_exit_functions.emplace([&]() {
+    pad_thread_stop.store(true);
+    if (pad_thread.joinable()) pad_thread.join();
+    // consoleExit to cleanup console (if you called consoleInit)
+    consoleExit(NULL);
+  });
 #else
   for (const int signal : {SIGWINCH, SIGTSTP}) {
     InstallSignalHandler(signal);
diff --git a/src/ftxui/screen/terminal.cpp b/src/ftxui/screen/terminal.cpp
index 8878a1f9..2964fc89 100644
--- a/src/ftxui/screen/terminal.cpp
+++ b/src/ftxui/screen/terminal.cpp
@@ -15,7 +15,9 @@
 
 #include <windows.h>
 #else
+#ifndef __SWITCH__
 #include <sys/ioctl.h>  // for winsize, ioctl, TIOCGWINSZ
+#endif
 #include <unistd.h>     // for STDOUT_FILENO
 #endif
 
@@ -107,6 +109,8 @@ Dimensions Size() {
   }
 
   return FallbackSize();
+#elif defined(__SWITCH__)
+  return Dimensions{80, 45};
 #else
   winsize w{};
   const int status = ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);  // NOLINT
