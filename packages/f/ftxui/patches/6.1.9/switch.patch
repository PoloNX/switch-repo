diff --git a/src/ftxui/component/loop.cpp b/src/ftxui/component/loop.cpp
index d16c67b4..247dd8a5 100644
--- a/src/ftxui/component/loop.cpp
+++ b/src/ftxui/component/loop.cpp
@@ -50,7 +50,11 @@ void Loop::RunOnceBlocking() {
 /// quitted.
 void Loop::Run() {
   while (!HasQuitted()) {
+    #ifndef __SWITCH__
     RunOnceBlocking();
+    #else 
+    RunOnce();
+    #endif
   }
 }
 
diff --git a/src/ftxui/component/screen_interactive.cpp b/src/ftxui/component/screen_interactive.cpp
index 77d164ac..88b6677a 100644
--- a/src/ftxui/component/screen_interactive.cpp
+++ b/src/ftxui/component/screen_interactive.cpp
@@ -48,7 +48,12 @@
 #endif
 #else
 #include <sys/select.h>  // for select, FD_ISSET, FD_SET, FD_ZERO, fd_set, timeval
+#ifndef __SWITCH__
 #include <termios.h>  // for tcsetattr, termios, tcgetattr, TCSANOW, cc_t, ECHO, ICANON, VMIN, VTIME
+#else
+#include <switch.h>
+#include <fcntl.h>
+#endif
 #include <unistd.h>  // for STDIN_FILENO, read
 #endif
 
@@ -160,6 +165,80 @@ void ftxui_on_resize(int columns, int rows) {
 }
 }
 
+#elif defined(__SWITCH__)
+void EventListener(std::atomic<bool>* quit, Sender<Task> out) {
+  // Configure input for one player with standard controller styles
+  padConfigureInput(1, HidNpadStyleSet_NpadStandard);
+
+  // Initialize the default gamepad (handles handheld + first connected pad)
+  PadState pad;
+  padInitializeDefault(&pad);
+
+  // Simple repeat for analog navigation
+  using clock = std::chrono::steady_clock;
+  auto last_nav = clock::now();
+  const auto repeat_delay = std::chrono::milliseconds(120);
+  const int stick_threshold = 20000;  // analog threshold
+
+  while (!*quit && appletMainLoop()) {
+    // Poll inputs once per frame
+    padUpdate(&pad);
+
+    // Button state
+    const u64 kDown = padGetButtonsDown(&pad);
+
+    // Mapping: buttons -> FTXUI events
+    auto send = [&](const Event& e) { out->Send(e); };
+
+    // Navigation via D-Pad
+    if (kDown & HidNpadButton_Up) send(Event::ArrowUp);
+    if (kDown & HidNpadButton_Down) send(Event::ArrowDown);
+    if (kDown & HidNpadButton_Left) send(Event::ArrowLeft);
+    if (kDown & HidNpadButton_Right) send(Event::ArrowRight);
+
+    // Validate / Back
+    if (kDown & HidNpadButton_A) send(Event::Return);
+    if (kDown & HidNpadButton_B) send(Event::Escape);
+
+    // Convenience mappings
+    if (kDown & HidNpadButton_X) send(Event::Tab);
+    if (kDown & HidNpadButton_Y) send(Event::Backspace);
+
+    // Shoulder buttons: page navigation
+    if (kDown & HidNpadButton_L) send(Event::PageUp);
+    if (kDown & HidNpadButton_R) send(Event::PageDown);
+
+    // Triggers: home/end
+    if (kDown & HidNpadButton_ZL) send(Event::Home);
+    if (kDown & HidNpadButton_ZR) send(Event::End);
+
+    // Plus as a generic "quit" signal: map to Ctrl+C (apps can handle it)
+    if (kDown & HidNpadButton_Plus) send(Event::CtrlC);
+
+    // Optional: allow analog stick to generate repeated navigation
+    const HidAnalogStickState lstick = padGetStickPos(&pad, 0);  // Left stick
+    const auto now = clock::now();
+    if (now - last_nav >= repeat_delay) {
+      if (lstick.y > stick_threshold) {
+        send(Event::ArrowUp);
+        last_nav = now;
+      } else if (lstick.y < -stick_threshold) {
+        send(Event::ArrowDown);
+        last_nav = now;
+      } else if (lstick.x < -stick_threshold) {
+        send(Event::ArrowLeft);
+        last_nav = now;
+      } else if (lstick.x > stick_threshold) {
+        send(Event::ArrowRight);
+        last_nav = now;
+      }
+    }
+
+    // Small sleep to avoid busy loop and align with frame rate
+    std::this_thread::sleep_for(std::chrono::milliseconds(10));
+  }
+}
+
 #else  // POSIX (Linux & Mac)
 
 int CheckStdinReady(int usec_timeout) {
@@ -506,17 +585,17 @@ bool ScreenInteractive::HasQuitted() {
 // private
 void ScreenInteractive::PreMain() {
   // Suspend previously active screen:
-  if (g_active_screen) {
-    std::swap(suspended_screen_, g_active_screen);
-    // Reset cursor position to the top of the screen and clear the screen.
-    suspended_screen_->ResetCursorPosition();
-    std::cout << suspended_screen_->ResetPosition(/*clear=*/true);
-    suspended_screen_->dimx_ = 0;
-    suspended_screen_->dimy_ = 0;
-
-    // Reset dimensions to force drawing the screen again next time:
-    suspended_screen_->Uninstall();
-  }
+  // if (g_active_screen) {
+  //   std::swap(suspended_screen_, g_active_screen);
+  //   // Reset cursor position to the top of the screen and clear the screen.
+  //   suspended_screen_->ResetCursorPosition();
+  //   std::cout << suspended_screen_->ResetPosition(/*clear=*/true);
+  //   suspended_screen_->dimx_ = 0;
+  //   suspended_screen_->dimy_ = 0;
+
+  //   // Reset dimensions to force drawing the screen again next time:
+  //   suspended_screen_->Uninstall();
+  // }
 
   // This screen is now active:
   g_active_screen = this;
@@ -610,7 +689,7 @@ void ScreenInteractive::Install() {
   // ensure it is fully applied:
   on_exit_functions.emplace([] { Flush(); });
 
-  on_exit_functions.emplace([this] { ExitLoopClosure()(); });
+  //on_exit_functions.emplace([this] { ExitLoopClosure()(); });
 
   // Request the terminal to report the current cursor shape. We will restore it
   // on exit.
@@ -657,6 +736,13 @@ void ScreenInteractive::Install() {
 
   SetConsoleMode(stdin_handle, in_mode);
   SetConsoleMode(stdout_handle, out_mode);
+#elif defined(__SWITCH__)
+  // --- Initialisation des services Switch ---
+  //consoleInit(NULL); // initialise la console texte ; utile pour debug/text output
+
+  // Configure l'entrée pour un joueur, styles standards de manettes
+  //padConfigureInput(1, HidNpadStyleSet_NpadStandard);
+
 #else
   for (const int signal : {SIGWINCH, SIGTSTP}) {
     InstallSignalHandler(signal);
@@ -734,7 +820,7 @@ void ScreenInteractive::Install() {
   event_listener_ =
       std::thread(&EventListener, &quit_, task_receiver_->MakeSender());
   animation_listener_ =
-      std::thread(&AnimationListener, &quit_, task_receiver_->MakeSender());
+     std::thread(&AnimationListener, &quit_, task_receiver_->MakeSender());
 }
 
 // private
@@ -763,6 +849,7 @@ void ScreenInteractive::RunOnce(Component component) {
     HandleTask(component, task);
     ExecuteSignalHandlers();
   }
+  
   Draw(std::move(component));
 
   if (selection_data_previous_ != selection_data_) {
@@ -903,6 +990,9 @@ bool ScreenInteractive::HandleSelection(bool handled, Event event) {
 // private
 // NOLINTNEXTLINE
 void ScreenInteractive::Draw(Component component) {
+  #ifdef __SWITCH__
+  consoleClear();
+  #endif
   if (frame_valid_) {
     return;
   }
@@ -1001,7 +1091,9 @@ void ScreenInteractive::Draw(Component component) {
     }
 
     if (cursor_.shape == Cursor::Hidden) {
+      #ifndef __SWITCH__
       set_cursor_position += "\033[?25l";
+      #endif
     } else {
       set_cursor_position += "\033[?25h";
       set_cursor_position +=
@@ -1011,6 +1103,9 @@ void ScreenInteractive::Draw(Component component) {
 
   std::cout << ToString() << set_cursor_position;
   Flush();
+  #ifdef __SWITCH__
+  consoleUpdate(NULL);
+  #endif
   Clear();
   frame_valid_ = true;
 }
diff --git a/src/ftxui/dom/benchmark_test.cpp b/src/ftxui/dom/benchmark_test.cpp
index 062cb234..e69de29b 100644
--- a/src/ftxui/dom/benchmark_test.cpp
+++ b/src/ftxui/dom/benchmark_test.cpp
@@ -1,86 +0,0 @@
-// Copyright 2021 Arthur Sonzogni. All rights reserved.
-// Use of this source code is governed by the MIT license that can be found in
-// the LICENSE file.
-#include <benchmark/benchmark.h>
-
-#include "ftxui/dom/elements.hpp"  // for gauge, separator, operator|, text, Element, hbox, vbox, blink, border, inverted
-#include "ftxui/dom/node.hpp"      // for Render
-#include "ftxui/screen/screen.hpp"  // for Screen
-
-// NOLINTBEGIN
-namespace ftxui {
-
-static void BencharkBasic(benchmark::State& state) {
-  while (state.KeepRunning()) {
-    auto document = vbox({
-                        text("Test"),
-                        separator(),
-                        hbox({
-                            gauge(0.9f),
-                            separator() | blink,
-                            gauge(0.5f),
-                            separator() | inverted,
-                            gauge(0.1f),
-                            separator(),
-                        }),
-                        text("Test"),
-                    }) |
-                    border;
-    auto root = gauge(1.0);
-    Screen screen(80, state.range(0));
-    Render(screen, root);
-    screen.ToString();
-  }
-}
-BENCHMARK(BencharkBasic)->DenseRange(0, 256, 16);
-
-static void BencharkText(benchmark::State& state) {
-  while (state.KeepRunning()) {
-    std::string content = "ＨＥＬＬＯ world ";
-    for (int i = 0; i < state.range(0); ++i) {
-      content += content;
-    }
-    auto document = paragraph(content);
-    Screen screen(200, 200);
-    Render(screen, document);
-    screen.ToString();
-  }
-}
-BENCHMARK(BencharkText)->DenseRange(0, 10, 1);
-
-static void BenchmarkStyle(benchmark::State& state) {
-  while (state.KeepRunning()) {
-    Elements elements;
-    for (int i = 0; i < state.range(0); ++i) {
-      elements.push_back(vbox({
-          text("Test") | bold,
-          text("Test") | dim,
-          text("Test") | inverted,
-          text("Test") | underlined,
-          text("Test") | underlinedDouble,
-          text("Test") | strikethrough,
-          text("Test") | color(Color::Red),
-          text("Test") | bgcolor(Color::Red),
-          text("Test") | color(Color::RGB(42, 87, 124)),
-          text("Test") | bgcolor(Color::RGB(42, 87, 124)),
-          text("Test") | color(Color::RGB(42, 87, 124)) |
-              bgcolor(Color::RGB(172, 94, 212)),
-          text("Test") | blink,
-          text("Test") | automerge,
-      }));
-      elements.push_back(separator());
-    }
-    auto document = hbox(std::move(elements));
-    Screen screen(state.range(1), state.range(1));
-    Render(screen, document);
-    screen.ToString();
-  }
-}
-BENCHMARK(BenchmarkStyle)
-    ->ArgsProduct({
-        benchmark::CreateDenseRange(1, 10, 3),     // Number of elements.
-        benchmark::CreateDenseRange(10, 200, 20),  // Screen width.
-    });
-
-}  // namespace ftxui
-// NOLINTEND
diff --git a/src/ftxui/screen/screen.cpp b/src/ftxui/screen/screen.cpp
index ab087fcc..9d3ad07a 100644
--- a/src/ftxui/screen/screen.cpp
+++ b/src/ftxui/screen/screen.cpp
@@ -23,6 +23,9 @@
 #include <windows.h>
 #endif
 
+#if defined(__SWITCH__)
+#include <switch.h>
+#endif
 // Macro for hinting that an expression is likely to be false.
 #if !defined(FTXUI_UNLIKELY)
 #if defined(COMPILER_GCC) || defined(__clang__)
@@ -406,6 +409,9 @@ Screen::Screen(int dimx, int dimy) : Image{dimx, dimy} {
   SetConsoleCP(CP_UTF8);
   WindowsEmulateVT100Terminal();
 #endif
+#if defined(__SWITCH__)
+consoleInit(NULL);
+#endif
 }
 
 /// Produce a std::string that can be used to print the Screen on the
diff --git a/src/ftxui/screen/terminal.cpp b/src/ftxui/screen/terminal.cpp
index 8878a1f9..2964fc89 100644
--- a/src/ftxui/screen/terminal.cpp
+++ b/src/ftxui/screen/terminal.cpp
@@ -15,7 +15,9 @@
 
 #include <windows.h>
 #else
+#ifndef __SWITCH__
 #include <sys/ioctl.h>  // for winsize, ioctl, TIOCGWINSZ
+#endif
 #include <unistd.h>     // for STDOUT_FILENO
 #endif
 
@@ -107,6 +109,8 @@ Dimensions Size() {
   }
 
   return FallbackSize();
+#elif defined(__SWITCH__)
+  return Dimensions{80, 45};
 #else
   winsize w{};
   const int status = ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);  // NOLINT
